# ADR-001: Redis for Session Cache

**ID**: ADR-001
**Date**: 2026-02-03
**Status**: Accepted
**Source**: Auto-generated from int_001
**Confidence**: 0.92

## Context

Performance bottleneck observed with 10k concurrent users. Session lookups
were hitting the database on every request, causing significant latency
and database load.

Original prompt:
> "Add Redis cache for user sessions, we have perf issues at 10k users"

## Decision

Implement Redis as a session cache layer between the application and database.

- Sessions are stored in Redis with TTL matching session expiry
- Database serves as fallback and persistence layer
- Session writes go to both Redis and DB (write-through)

## Alternatives Considered

| Alternative | Reason Rejected |
|------------|-----------------|
| Memcached | No persistence, fewer data structures, less ecosystem support |
| In-memory LRU | Doesn't scale horizontally across multiple server instances |
| Database optimization | Would only delay the problem, not solve fundamental I/O bottleneck |

## Implementation

Files modified:
- `src/auth/session.ts` - Session middleware with Redis lookup
- `src/config/redis.ts` - Redis connection configuration

Key code pattern:
```typescript
// Check Redis first, fallback to DB
const session = await redis.get(`session:${id}`) 
  || await db.sessions.findById(id);
```

## Consequences

### Positive
- Session lookups reduced from ~50ms to ~2ms
- Database load reduced by approximately 80%
- Horizontal scaling now possible

### Negative
- New infrastructure dependency (Redis)
- Need to handle Redis connection failures gracefully
- Additional operational complexity (monitoring, backups)
- Slight consistency window between Redis and DB

## Follow-up

- int_002: Fixed connection pool issue discovered during implementation
- Consider Redis Cluster for high availability

## Related

- **Intents**: int_001, int_002
- **Commits**: a1b2c3d, b2c3d4e
- **Concepts**: caching, sessions, performance, scalability
